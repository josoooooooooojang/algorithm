  ## 1. 풀이
    - 기본 최솟값을 필요한 만큼 입력해놓음
      => dp[1] : 1은 그대로 이므로 '0'을 저장
      => dp[2] : 2를 2로 나누면 1번이므로 '1' 
      
    - 동적 프로그래밍 계산
      => 우선 i - 1번 째 최솟값으로 등록
      => 현재 값이 2로 나뉘어질 때 현재 최솟값, 즉 i - 1번 째와 i / 2번 째 값을 비교
      => 현재 값이 3으로 나뉘어질 때 위에서 구해내려온 최솟값과 i / 3번 째 값과 비교
      => 현재의 경우를 포함해야하므로 최종 최솟값에 1을 더함.
      
      - N번째 최솟값을 출력
      
  ## 2. 추가 설명
    - 기본 최솟값을 2까지 구해놓는 이유
      => n의 최솟값은 아래 세 가지 경우 중 하나임
           n을 3으로 나눈 값의 최솟값에 + 1, 
           n을 2로 나눈 값의 최솟값에 + 1, 
           n보다 1 작은 값의 최솟값에 + 1
      => 각 경우의 탐색범위가 가장 큰 경우는 3으로 나누는 경우
      => 나눴을 때 최소 인덱스인 1이 나오게 하기 위함
      => 'n = 1', 'n = 2' 는 n/3 탐색시 유효하지 않음
      
    - 2로 나눠지고 3으로도 나눠지는 경우를 따로 놓지 않은 이유
      => 가능한 경우를 내려오면서 결국 가장 작은 최솟값으로 도출될 것이기 때문
      => 2로 나누는 케이스와 3으로 나누는 케이스 순서를 바꿔도 동일한 결과가 나옴
      

    
```c++
#include <iostream>
#define min(a, b)    (a < b ? a : b)
using namespace std;
    
int main(){
    int N;
    cin >> N;
    
    int dp[1000000];
    dp[1] = 0;
    dp[2] = 1;
    for(int i = 3; i <= N; i++){
        dp[i] = dp[i - 1];
        dp[i] = i % 3 == 0 ? min(dp[i / 3], dp[i]) : dp[i];
        dp[i] = i % 2 == 0 ? min(dp[i / 2], dp[i]) : dp[i];
        dp[i] += 1;
    }
    
    cout << dp[N];
    
    return 0;
}
```
  
      
